/*
 * Copyright (c) 2012 Salzburg Research.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





apply plugin: 'osgi'

/*
apply plugin:com.smokejumperit.gradle.compiler.JavaccPlugin
apply plugin:com.smokejumperit.gradle.compiler.JJTreePlugin

buildscript {
    repositories {
        maven {
            url "http://devel.kiwi-project.eu:8080/nexus/content/groups/public/"
        }
    }
  dependencies {
        classpath "com.google.guava:guava:10.0.1"
        classpath 'com.smokejumperit.gradle.compiler:javacc:0.0.3'
  }
}
*/

buildscript {
    repositories {
        maven {
            url "http://devel.kiwi-project.eu:8080/nexus/content/groups/public/"
        }
    }
    dependencies {
        classpath 'net.java.dev.javacc:javacc:5.0'
    }
}

dependencies {
    compile project(':ldpath-core')
}
sourceSets {
    main {
        java {
            srcDir rootProject.project('ldpath-core').sourceSets.main.java
        }
        resources {
            srcDir rootProject.project('ldpath-core').sourceSets.main.resources
        }
    }
}


jar { //use the default jar for OSGI
    manifest { // the manifest of the default jar is of type OsgiManifest
        //attributes  'Implementation-Title': 'LD Path Core', 'Implementation-Version': version
        name = 'LD-Path Implementation Core'
        instruction 'Export-Package',
            "at.newmedialab.ldpath;version="+version,
            "at.newmedialab.ldpath.exception;version="+version,
            "at.newmedialab.ldpath.model;version="+version,
            "at.newmedialab.ldpath.model.backend;version="+version,
            "at.newmedialab.ldpath.model.fields;version="+version,
            "at.newmedialab.ldpath.model.functions;version="+version,
            "at.newmedialab.ldpath.model.programs;version="+version,
            "at.newmedialab.ldpath.model.selectors;version="+version,
            "at.newmedialab.ldpath.model.tests;version="+version,
            "at.newmedialab.ldpath.model.transformers;version="+version,
            "at.newmedialab.ldpath.parser;version="+version,
            "at.newmedialab.ldpath.util;version="+version
        instruction 'Embed-Dependency',
            'guava',
            'htmlcleaner',
            'jdom'
        instruction 'Import-Package',
        //exclude packages of embedded dependencies
            '!com.google.common.*', 
            '!org.htmlcleaner.*',
            '!org.jdom.*',
            '*'
        instruction 'Embed-Transitive', 'true'
        instruction 'Bundle-Vendor', 'Salzburg Research'
        instruction 'Bundle-Category', 'LD-Path'
        instruction 'Bundle-Description', 'Core Implementation of LD Path a simple path-based query language similar to XPath or SPARQL Property Paths that is particularly well-suited for querying and retrieving resources from the Linked Data Cloud by following RDF links between resources and servers.'
        instruction 'Bundle-DocURL', 'http://code.google.com/p/ldpath/'
        instruction 'Bundle-License', 'http://www.apache.org/licenses/LICENSE-2.0.txt'
    }
}

/*
 * reads the OSGI instruction "Embed-Dependency" and "Embed-Transitive"
 * amd stes the "Bundle-ClassPath" instruction as well as copy instraction for
 * the related artifacts accordingly
 */
task processEmbedded << {
    embedInstruction = jar.manifest.instructions.get("Embed-Dependency")
    transitive = jar.manifest.instructions.get("Embed-Transitive");
    if(embedInstruction != null){
        def includedArtifacts = [] as Set
        getDependencies(embedInstruction,transitive).each { dependency ->
            dependency.moduleArtifacts.each { artifact ->
                includedArtifacts.add(artifact.file)
            }
        }
        jar.manifest.instruction("Bundle-ClassPath",'.') //add the default classpath
        includedArtifacts.each { artifact ->
            jar.from(artifact)
            jar.manifest.instruction("Bundle-ClassPath",artifact.name)
        }
    }
}

/**
 * Gets the list of ResolvedDependencies for the list of embeded dependency names
 * @param embededList the list with the dependencies to embed
 * @param recursive The embed transitive state
 * @return the list of dependencies. An empty Set if none
 */
def getDependencies(embededList, recursive){
    def dependencies = [] as Set //resolved Dependencies
    def dependencyMap = [:]; 
    // This only considers top level resolved dependencies, but other should 
    // not be embeded anyway.
    rootProject.project('ldpath-core').configurations.runtime.resolvedConfiguration.firstLevelModuleDependencies.each { dependency ->
        dependencyMap.put(dependency.moduleName,dependency)
    }
    embededList.each { embeded -> 
        dependency = dependencyMap.get(embeded)
        if(dependency != null){
            println "dependency "+dependency.name
            dependencies.add(dependency)
            if(recursive){
                dependency.children.each { child -> 
                    println "  child "+child.name+" Parents: "+child.parents
                    dependencies.add(child) 
                }
            }
        } else {
            println "WARNING: dependency "+embeded+" not found"
        }
    }
    return dependencies
}

install { //remove test dependencies
    repositories['mavenInstaller'].with {
        pom.whenConfigured { pom ->
            //println "id: "+ pom.artifactId
            //pom.dependencies.each { dep -> println "dependency: groupId="+ dep.groupId+" | artifactId="+ dep.artifactId + " | scope=" + dep.scope}
            pom.dependencies.removeAll { dep -> 
                dep.scope == 'test'} // removes the test scoped ones
            pom.dependencies.removeAll { dep -> 
                dep.artifactId == 'log4j-over-slf4j' ||
                dep.artifactId == 'slf4j-ext' ||
                dep.artifactId == 'logback-classic' || 
                dep.artifactId == 'jcl-over-slf4j' }
            //println "- - -"
            //pom.dependencies.each { dep -> println "dependency "+ dep}
         }
    }
}

uploadArchives { //remove test dependencies
    repositories['mavenDeployer'].with {
        pom.whenConfigured { pom ->
            pom.dependencies.removeAll { dep -> 
                dep.scope == 'test'} // removes the test scoped ones
            pom.dependencies.removeAll { dep -> 
                dep.artifactId == 'log4j-over-slf4j' ||
                dep.artifactId == 'slf4j-ext' ||
                dep.artifactId == 'logback-classic' || 
                dep.artifactId == 'jcl-over-slf4j' }
        }
    }
}
project(':') {
    dependencies {
        runtime project('ldpath-core-bundle')
    }
}
compileJava.dependsOn processEmbedded
//ensure that the license is added
task copyLicense(type:Copy) {
    from 'LICENSE'
    into 'build/classes/main/META-INF'
}
jar.dependsOn copyLicense
