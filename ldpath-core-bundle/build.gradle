/*
 * Copyright (c) 2012 Salzburg Research.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





apply plugin: 'osgi'

// the configuration of this module (used for the POM and the MANIFEST)
def pomConfig = [
    name: "LD-Path Implementation Core Bundle",
    description: "Core Implementation of LD Path a simple path-based query language "
        + "similar to XPath or SPARQL Property Paths that is particularly well-suited "
        + "for querying and retrieving resources from the Linked Data Cloud by "
        + "following RDF links between resources and servers.",
    packaging: "bundle"] as Map;

buildscript {
    repositories {
        maven {
            url "http://devel.kiwi-project.eu:8080/nexus/content/groups/public/"
        }
    }
    dependencies {
        classpath 'net.java.dev.javacc:javacc:5.0'
    }
}

dependencies {
    compile project(':ldpath-core')
}
sourceSets {
    main {
        java {
            srcDir rootProject.project('ldpath-core').sourceSets.main.java
        }
        resources {
            srcDir rootProject.project('ldpath-core').sourceSets.main.resources
        }
    }
}
//signing {
//    sign configurations.archives
//}

jar { //use the default jar for OSGI
    manifest { // the manifest of the default jar is of type OsgiManifest
        //attributes  'Implementation-Title': 'LD Path Core', 'Implementation-Version': version
        name = pomConfig['name']
        instruction 'Export-Package',
            "at.newmedialab.ldpath;version="+version,
            "at.newmedialab.ldpath.exception;version="+version,
            "at.newmedialab.ldpath.model;version="+version,
            "at.newmedialab.ldpath.model.backend;version="+version,
            "at.newmedialab.ldpath.model.fields;version="+version,
            "at.newmedialab.ldpath.model.functions;version="+version,
            "at.newmedialab.ldpath.model.programs;version="+version,
            "at.newmedialab.ldpath.model.selectors;version="+version,
            "at.newmedialab.ldpath.model.tests;version="+version,
            "at.newmedialab.ldpath.model.transformers;version="+version,
            "at.newmedialab.ldpath.parser;version="+version,
            "at.newmedialab.ldpath.util;version="+version
        instruction 'Embed-Dependency',
            'guava',
            'htmlcleaner',
            'jdom'
        instruction 'Import-Package',
        //exclude packages of embedded dependencies
            '!com.google.common.*', 
            '!org.htmlcleaner.*',
            '!org.jdom.*',
            '*'
        instruction 'Embed-Transitive', 'true'
        instruction 'Bundle-Vendor', 'Salzburg Research'
        instruction 'Bundle-Category', 'LD-Path'
        instruction 'Bundle-Description', pomConfig['description']
        instruction 'Bundle-DocURL', 'http://code.google.com/p/ldpath/'
        instruction 'Bundle-License', 'http://www.apache.org/licenses/LICENSE-2.0.txt'
    }
}

// custom tasks for creating source/javadoc jars
task sourcesJar(type: org.gradle.api.tasks.bundling.Jar, dependsOn:classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: org.gradle.api.tasks.bundling.Jar, dependsOn:javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

// add javadoc/source jar tasks as artifacts
artifacts {
    archives jar
    archives sourcesJar
    archives javadocJar
}

/*
 * reads the OSGI instruction "Embed-Dependency" and "Embed-Transitive"
 * amd stes the "Bundle-ClassPath" instruction as well as copy instraction for
 * the related artifacts accordingly
 */
task processEmbedded << {
    embedInstruction = jar.manifest.instructions.get("Embed-Dependency")
    transitive = jar.manifest.instructions.get("Embed-Transitive");
    if(embedInstruction != null){
        def includedArtifacts = [] as Set
        getDependencies(embedInstruction,transitive).each { dependency ->
            dependency.moduleArtifacts.each { artifact ->
                includedArtifacts.add(artifact.file)
            }
        }
        jar.manifest.instruction("Bundle-ClassPath",'.') //add the default classpath
        includedArtifacts.each { artifact ->
            jar.from(artifact)
            jar.manifest.instruction("Bundle-ClassPath",artifact.name)
        }
    }
}

/**
 * Gets the list of ResolvedDependencies for the list of embeded dependency names
 * @param embededList the list with the dependencies to embed
 * @param recursive The embed transitive state
 * @return the list of dependencies. An empty Set if none
 */
def getDependencies(embededList, recursive){
    def dependencies = [] as Set //resolved Dependencies
    def dependencyMap = [:]; 
    // This only considers top level resolved dependencies, but other should 
    // not be embeded anyway.
    rootProject.project('ldpath-core').configurations.runtime.resolvedConfiguration.firstLevelModuleDependencies.each { dependency ->
        dependencyMap.put(dependency.moduleName,dependency)
    }
    embededList.each { embeded -> 
        dependency = dependencyMap.get(embeded)
        if(dependency != null){
            println "dependency "+dependency.name
            dependencies.add(dependency)
            if(recursive){
                dependency.children.each { child -> 
                    println "  child "+child.name+" Parents: "+child.parents
                    dependencies.add(child) 
                }
            }
        } else {
            println "WARNING: dependency "+embeded+" not found"
        }
    }
    return dependencies
}

install { //remove test dependencies
    repositories['mavenInstaller'].with {
        configurePom(pom,pomConfig)
        beforeDeployment { MavenDeployment deployment ->
            println "Pubished Artifacts: "
            deployment.artifacts.each{ PublishArtifact artifact ->
                println " > name: " + artifact.name + " | file: " + artifact.file +
                    " | type: "+artifact.type + " | ext: " + artifact.extension +
                    " | classifier " + artifact.classifier;
            }
            //signing deactivated for now!
   //            signPom(deployment)
        }
   
    }
}

uploadArchives { //remove test dependencies
    repositories['mavenDeployer'].with {
        beforeDeployment { MavenDeployment deployment -> signPom(deployment) }

        repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
          authentication(userName: 'dummy', password: 'dummy')
        }
        configurePom(pom,pomConfig)
    }
}

project(':') {
    dependencies {
        runtime project('ldpath-core-bundle')
    }
}
compileJava.dependsOn processEmbedded
//ensure that the license is added
task copyLicense(type:Copy) {
    from 'LICENSE'
    into 'build/classes/main/META-INF'
}
jar.dependsOn copyLicense
